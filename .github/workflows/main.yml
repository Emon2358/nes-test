name: MID → MML → NSF converter

on:
  push:
    paths:
      - 'mids/**'
  workflow_dispatch:
    inputs:
      mid_filename:
        description: '（任意）処理したい mids/<filename.mid> を指定。未指定なら mids/ 内の全てを処理'
        required: false
        default: ''

permissions:
  contents: read
  actions: write

jobs:
  convert:
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create working dirs
        shell: pwsh
        run: |
          New-Item -Path tools -ItemType Directory -Force | Out-Null
          New-Item -Path output -ItemType Directory -Force | Out-Null

      - name: Download tool archives
        shell: pwsh
        run: |
          $mid2mmlUrl = "http://zex0.web.fc2.com/tool/mid2mml_v1.0b.lzh"
          $ppmckUrl   = "http://ppmck.web.fc2.com/ppmck/ppmck09a.zip"
          Invoke-WebRequest -Uri $mid2mmlUrl -OutFile "tools\mid2mml_v1.0b.lzh" -UseBasicParsing
          Invoke-WebRequest -Uri $ppmckUrl   -OutFile "tools\ppmck09a.zip"   -UseBasicParsing

      - name: Extract archives (7z on windows runner)
        shell: pwsh
        run: |
          # ensure destination folders
          New-Item -Path tools\mid2mml -ItemType Directory -Force | Out-Null
          New-Item -Path tools\ppmck -ItemType Directory -Force | Out-Null

          # 7z が PATH にある前提. -y を付けて上書き確認を無視
          if (-not (Get-Command 7z -ErrorAction SilentlyContinue)) {
            Write-Host "7z not found in PATH - extraction will likely fail"
            exit 1
          }

          & 7z x "tools\mid2mml_v1.0b.lzh" "-otools\mid2mml" -y
          & 7z x "tools\ppmck09a.zip" "-otools\ppmck" -y

      - name: List extracted files (for debugging)
        shell: pwsh
        run: |
          Write-Host "=== tools/mid2mml ==="
          if (Test-Path "./tools/mid2mml") {
            Get-ChildItem -Path "./tools/mid2mml" -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "tools/mid2mml not found"
          }

          Write-Host "=== tools/ppmck ==="
          if (Test-Path "./tools/ppmck") {
            Get-ChildItem -Path "./tools/ppmck" -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "tools/ppmck not found"
          }

      - name: Convert .mid -> .mml and .mml -> .nsf
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $midDir = Join-Path $PWD "mids"
          if (-not (Test-Path $midDir)) {
            Write-Host "No mids directory found; nothing to do."
            exit 0
          }

          $outDir = Join-Path $PWD "output"
          New-Item -Path $outDir -ItemType Directory -Force | Out-Null

          # If workflow_dispatch provided a filename, only process that
          $inputMid = "${{ github.event.inputs.mid_filename }}"
          if ($inputMid -and $inputMid.Trim() -ne "") {
            $searchPattern = $inputMid
            Write-Host "Manual run: targeting specific file: $searchPattern"
            $mids = Get-ChildItem -Path $midDir -Filter $searchPattern -Recurse -ErrorAction SilentlyContinue
          } else {
            $mids = Get-ChildItem -Path $midDir -Filter *.mid -Recurse -ErrorAction SilentlyContinue
          }

          if ($null -eq $mids -or $mids.Count -eq 0) {
            Write-Host "No .mid files found under mids/. Exiting."
            exit 0
          }

          # find possible executables
          $mid2mmlExe = Get-ChildItem -Path (Join-Path $PWD "tools\mid2mml") -Filter *.exe -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -eq $mid2mmlExe) {
            Write-Warning "mid2mml executable not found in tools/mid2mml. Listing files:"
            Get-ChildItem -Path tools\mid2mml -Recurse | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "Using mid2mml exe: $($mid2mmlExe.FullName)"
          }

          $ppmckExe = Get-ChildItem -Path (Join-Path $PWD "tools\ppmck") -Filter *.exe -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -eq $ppmckExe) {
            Write-Warning "ppmck executable not found in tools/ppmck. Listing files:"
            Get-ChildItem -Path tools\ppmck -Recurse | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "Using ppmck exe: $($ppmckExe.FullName)"
          }

          foreach ($mid in $mids) {
            Write-Host "---- Processing $($mid.FullName) ----"

            # 1) MID -> MML
            $mmlPath = Join-Path $outDir ($mid.BaseName + ".mml")
            $tempMmlCandidates = @()

            if ($mid2mmlExe -ne $null) {
              Write-Host "Attempting to run mid2mml (best-effort)..."
              Push-Location $mid2mmlExe.DirectoryName
              try {
                & $mid2mmlExe.FullName $mid.FullName
              } catch {
                Write-Warning "mid2mml run (simple) failed: $_"
              }

              try {
                & $mid2mmlExe.FullName "-i" $mid.FullName "-o" $mmlPath
              } catch {
                # ignore
              }
              Pop-Location

              # Search for recently created .mml files
              $candidates = Get-ChildItem -Path . -Include *.mml -Recurse -ErrorAction SilentlyContinue |
                            Where-Object { $_.LastWriteTime -gt (Get-Date).AddMinutes(-10) } |
                            Sort-Object LastWriteTime -Descending
              foreach ($c in $candidates) {
                $tempMmlCandidates += $c.FullName
              }
            } else {
              Write-Warning "No mid2mml exe found; skipping .mid -> .mml."
            }

            if ($tempMmlCandidates.Count -gt 0) {
              $chosen = $tempMmlCandidates | Select-Object -First 1
              Write-Host "Found generated .mml: $chosen"
              Copy-Item -Path $chosen -Destination $mmlPath -Force
            } else {
              Write-Warning "No .mml generated automatically; creating placeholder MML."
              "$($mid.BaseName) // placeholder mml (conversion may have failed)" | Out-File -FilePath $mmlPath -Encoding ascii
            }

            # 2) MML -> NSF (using ppmck)
            if ($ppmckExe -ne $null) {
              $nsfPath = Join-Path $outDir ($mid.BaseName + ".nsf")
              Write-Host "Attempting to run ppmck to produce $nsfPath"

              Push-Location $ppmckExe.DirectoryName
              try {
                & $ppmckExe.FullName "-o" $nsfPath $mmlPath
              } catch {
                Write-Warning "ppmck run variant 1 failed: $_"
              }
              if (-not (Test-Path $nsfPath)) {
                try {
                  & $ppmckExe.FullName $mmlPath "-o" $nsfPath
                } catch {
                  Write-Warning "ppmck run variant 2 failed: $_"
                }
              }
              Pop-Location

              if (Test-Path $nsfPath) {
                Write-Host "Created NSF: $nsfPath"
              } else {
                Write-Warning "NSF not created for $($mid.Name). Check ppmck usage / exe."
              }
            } else {
              Write-Warning "ppmck exe not found; skipping MML -> NSF for $($mid.Name)"
            }

          } # each mid

          Write-Host "Conversion step finished. Output files:"
          Get-ChildItem -Path $outDir -Recurse | ForEach-Object { Write-Host $_.FullName }

      - name: Upload output artifacts
        uses: actions/upload-artifact@v4
        with:
          name: converted-artifacts
          path: output/**

      - name: Workflow finished - debug listing
        shell: pwsh
        run: |
          Write-Host "=== FINAL OUTPUT ==="
          if (Test-Path ./output) { Get-ChildItem -Path ./output -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "No output folder." }

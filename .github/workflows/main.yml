name: MID → MML → NSF converter

on:
  push:
    paths:
      - 'mids/**'
  workflow_dispatch:
    inputs:
      mid_filename:
        description: '（任意）処理したい mids/<filename.mid> を指定。未指定なら mids/ 内の全てを処理'
        required: false
        default: ''

permissions:
  contents: read
  actions: write

jobs:
  convert:
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create working dirs
        shell: pwsh
        run: |
          New-Item -Path tools -ItemType Directory -Force | Out-Null
          New-Item -Path output -ItemType Directory -Force | Out-Null

      - name: Download tool archives
        shell: pwsh
        run: |
          $mid2mmlUrl = "http://zex0.web.fc2.com/tool/mid2mml_v1.0b.lzh"
          $ppmckUrl   = "http://ppmck.web.fc2.com/ppmck/ppmck09a.zip"
          Invoke-WebRequest -Uri $mid2mmlUrl -OutFile "tools\mid2mml_v1.0b.lzh" -UseBasicParsing
          Invoke-WebRequest -Uri $ppmckUrl   -OutFile "tools\ppmck09a.zip"   -UseBasicParsing

      - name: Extract archives (7z on windows runner)
        shell: pwsh
        run: |
          New-Item -Path tools\mid2mml -ItemType Directory -Force | Out-Null
          New-Item -Path tools\ppmck -ItemType Directory -Force | Out-Null
          if (-not (Get-Command 7z -ErrorAction SilentlyContinue)) {
            Write-Host "7z not found in PATH - extraction will likely fail"
            exit 1
          }
          & 7z x "tools\mid2mml_v1.0b.lzh" "-otools\mid2mml" -y
          & 7z x "tools\ppmck09a.zip" "-otools\ppmck" -y

      - name: List extracted files (for debugging)
        shell: pwsh
        run: |
          Write-Host "=== tools/mid2mml ==="
          if (Test-Path "./tools/mid2mml") {
            Get-ChildItem -Path "./tools/mid2mml" -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else { Write-Host "tools/mid2mml not found" }
          Write-Host "=== tools/ppmck ==="
          if (Test-Path "./tools/ppmck") {
            Get-ChildItem -Path "./tools/ppmck" -Recurse -Force | ForEach-Object { Write-Host $_.FullName }
          } else { Write-Host "tools/ppmck not found" }

      - name: Convert .mid -> .mml and .mml -> .nsf (robust)
        shell: pwsh
        run: |
          # NB: this step is robust: it logs ppmck stdout/stderr, checks file existence,
          # uses input->output argument order, and does not fail the entire job on ppmck error.

          $midDir = Join-Path $PWD "mids"
          if (-not (Test-Path $midDir)) {
            Write-Host "No mids directory found; nothing to do."
            exit 0
          }
          $outDir = Join-Path $PWD "output"
          New-Item -Path $outDir -ItemType Directory -Force | Out-Null

          $inputMid = "${{ github.event.inputs.mid_filename }}"
          if ($inputMid -and $inputMid.Trim() -ne "") {
            Write-Host "Manual run: targeting specific file: $inputMid"
            $mids = Get-ChildItem -Path $midDir -Filter $inputMid -Recurse -ErrorAction SilentlyContinue
          } else {
            $mids = Get-ChildItem -Path $midDir -Filter *.mid -Recurse -ErrorAction SilentlyContinue
          }

          if ($null -eq $mids -or $mids.Count -eq 0) {
            Write-Host "No .mid files found under mids/. Exiting."
            exit 0
          }

          $mid2mmlExe = Get-ChildItem -Path (Join-Path $PWD "tools\mid2mml") -Filter *.exe -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -eq $mid2mmlExe) {
            Write-Warning "mid2mml executable not found in tools/mid2mml. Listing files:"
            Get-ChildItem -Path tools\mid2mml -Recurse | ForEach-Object { Write-Host $_.FullName }
          } else { Write-Host "Using mid2mml exe: $($mid2mmlExe.FullName)" }

          $ppmckExe = Get-ChildItem -Path (Join-Path $PWD "tools\ppmck") -Filter *.exe -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -eq $ppmckExe) {
            Write-Warning "ppmck executable not found in tools/ppmck. Listing files:"
            Get-ChildItem -Path tools\ppmck -Recurse | ForEach-Object { Write-Host $_.FullName }
          } else { Write-Host "Using ppmck exe: $($ppmckExe.FullName)" }

          foreach ($mid in $mids) {
            Write-Host "---- Processing $($mid.FullName) ----"
            $mmlPath = Join-Path $outDir ($mid.BaseName + ".mml")
            $tempMmlCandidates = @()

            if ($mid2mmlExe -ne $null) {
              Write-Host "Running mid2mml (best-effort) to produce .mml..."
              Push-Location $mid2mmlExe.DirectoryName
              try { & $mid2mmlExe.FullName $mid.FullName } catch { Write-Warning "mid2mml run (simple) failed: $_" }
              try { & $mid2mmlExe.FullName "-i" $mid.FullName "-o" $mmlPath } catch {}
              Pop-Location

              # pick up any recent .mml outputs
              $candidates = Get-ChildItem -Path . -Include *.mml -Recurse -ErrorAction SilentlyContinue |
                            Where-Object { $_.LastWriteTime -gt (Get-Date).AddMinutes(-10) } |
                            Sort-Object LastWriteTime -Descending
              foreach ($c in $candidates) { $tempMmlCandidates += $c.FullName }
            } else {
              Write-Warning "No mid2mml exe found; skipping .mid -> .mml."
            }

            if ($tempMmlCandidates.Count -gt 0) {
              $chosen = $tempMmlCandidates | Select-Object -First 1
              Write-Host "Found generated .mml: $chosen"
              Copy-Item -Path $chosen -Destination $mmlPath -Force
            } else {
              Write-Warning "No .mml generated automatically; creating placeholder MML so ppmck can at least be invoked."
              "$($mid.BaseName) // placeholder mml (conversion may have failed)" | Out-File -FilePath $mmlPath -Encoding ascii
            }

            # MML -> NSF using ppmck: use explicit argument order: input.mml then output.nsf
            if ($ppmckExe -ne $null) {
              if (-not (Test-Path $mmlPath)) {
                Write-Warning "MML file missing: $mmlPath - skipping ppmck for this mid."
                continue
              }

              $nsfPath = Join-Path $outDir ($mid.BaseName + ".nsf")
              Write-Host "Running ppmck: input -> output"
              Push-Location $ppmckExe.DirectoryName

              # ensure old logs removed
              if (Test-Path "./ppmck_stdout.txt") { Remove-Item "./ppmck_stdout.txt" -Force }
              if (Test-Path "./ppmck_stderr.txt") { Remove-Item "./ppmck_stderr.txt" -Force }

              # Use Start-Process to capture stdout/stderr and get exit code
              $argList = @("$mmlPath", "$nsfPath")
              $proc = Start-Process -FilePath $ppmckExe.FullName -ArgumentList $argList -NoNewWindow -Wait -PassThru -RedirectStandardOutput "./ppmck_stdout.txt" -RedirectStandardError "./ppmck_stderr.txt"
              $exit = $proc.ExitCode
              Write-Host "ppmck exit code: $exit"
              if (Test-Path "./ppmck_stdout.txt") { Write-Host "---- ppmck stdout ----"; Get-Content "./ppmck_stdout.txt" | ForEach-Object { Write-Host $_ } }
              if (Test-Path "./ppmck_stderr.txt") { Write-Host "---- ppmck stderr ----"; Get-Content "./ppmck_stderr.txt" | ForEach-Object { Write-Host $_ } }

              Pop-Location

              if ($exit -eq 0 -and (Test-Path $nsfPath)) {
                Write-Host "Created NSF: $nsfPath"
              } else {
                Write-Warning "ppmck failed or NSF not created for $($mid.Name). Exit code: $exit"
                # keep going; do not fail the whole workflow so we can still collect logs/artifacts
              }
            } else {
              Write-Warning "ppmck exe not found; skipping MML -> NSF for $($mid.Name)"
            }

          } # foreach mid

          Write-Host "Conversion step finished. Output files (output/):"
          if (Test-Path $outDir) { Get-ChildItem -Path $outDir -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "No output folder." }

          # ensure script exits successfully so the artifacts step will run
          exit 0

      - name: Upload output artifacts
        uses: actions/upload-artifact@v4
        with:
          name: converted-artifacts
          path: output/**

      - name: Workflow finished - debug listing
        shell: pwsh
        run: |
          Write-Host "=== FINAL OUTPUT ==="
          if (Test-Path ./output) { Get-ChildItem -Path ./output -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "No output folder." }
